classdef EKF < handle
    % filter

    properties
        X
        Dt
        x_pred

        R1
        Q1
        R2
        Q2
        R3
        Q3
        R4
        Q4
        P1
        P2
        P3
        P4
        K1
        K2
        K3
        K4
        debug
    end
    
    methods
        function obj = EKF(X0, Dt)
            obj.Dt = Dt;
            obj.x_pred = zeros(8,1);
            % filter covariances
            % AUV horizontal
            obj.R1 = eye(2); 
            obj.Q1 = kron([1,0;0,0.001],eye(2));
            % AUV Rotational
            obj.R2 = 1;
            obj.Q2 = 0.1;
            % DS horizontal
            obj.R3 = 2*eye(2);
            obj.Q3 = eye(2);
            % DS Orientation
            obj.R4 = 1;
            obj.Q4 = 0.001;


            % Initialization 
            obj.X = X0;
            % internal filter covariances initialization
            obj.P1 = eye(4);
            obj.P2 = 1;
            obj.P3 = eye(2);
            obj.P4 = 1;

            
            % solve for linear kf for horizontal filter
            obj.K1 = dlqe(eye(4)+kron([0,Dt;0,0],eye(2)), eye(4), kron([1,0],eye(2)), obj.Q1, obj.R1);
            % solve for linear kf for rotational
            obj.K2 = dlqe(1,1,1, obj.Q2, obj.R2);
            % solve for linear kf for dock yaw
            obj.K4 = dlqe(1,1,1, obj.Q4, obj.R4);
            
            obj.debug = zeros(2,1);
        end
        
        function obj = predict(obj, input)
            %horizontal filter
            A = eye(4)+kron([0,obj.Dt;0,0],eye(2));
            B = kron([obj.Dt;0],eye(2));
            obj.x_pred(1:4) = A*obj.X(1:4)+B*input;
            obj.P1 = A*obj.P1*A' + obj.Q1;
            
            % rotational filter
            obj.x_pred(5) = obj.X(5);
            obj.P2 = obj.P2 + obj.Q2;

            % dock position estimate filter
            obj.x_pred(6:7) = obj.X(6:7);
            obj.P3 = obj.P3 + obj.Q3;
            
            % dock orientation estimate filter
            obj.x_pred(8) = obj.X(8);
            obj.P4 = obj.P4 + obj.Q4;     
        end

        function obj = update(obj, y)
            % horizontal filter
            C= kron([1,0],eye(2));
            obj.X(1:4) = obj.x_pred(1:4) + obj.K1*(y(1:2) - C*obj.x_pred(1:4));
            obj.P1 = (eye(4) - obj.K1*C)*obj.P1;
            
            % rotational filter
            obj.X(5) = obj.x_pred(5) + obj.K2*(y(5) - obj.x_pred(5));
            obj.P2 = (1 - obj.K2)*obj.P2;

            % dock position estimate filter
            d  = (obj.X(1)-obj.X(7))^2 + (obj.X(2)-obj.X(8))^2 ;
            H = [(obj.X(6)-obj.X(1))/sqrt(d), (obj.X(7)-obj.X(2))/sqrt(d);
                (obj.X(2)-obj.X(7))/d, (obj.X(6)-obj.X(1))/d];

            obj.K3 = (obj.P3*H')/(H*obj.P3*H' + obj.R3);
            y_ = [sqrt(y(4)^2+y(5)^2); atan2d(y(5),y(4))];
            hx_ = [sqrt( (obj.X(1)-obj.X(6))^2 + (obj.X(2)-obj.X(7))^2 ); wrapTo180(atan2d((obj.X(7)-obj.X(2)), (obj.X(6)-obj.X(1))) - obj.X(8))];
            obj.debug = (y_-hx_);
            obj.X(6:7) = obj.x_pred(6:7) + obj.K3*(y_-hx_);
            obj.P3 = (eye(2) - obj.K3*H)*obj.P3;
            
            % dock orientation estimate filter
            r1 = -dot(y(6:7),y(4:5));
            r2 = [0,0,1]*cross([y(6:7);0],[y(4:5);0]);
            y_ = atan2d(r2,r1) + obj.X(5);
            obj.X(8) = obj.x_pred(8) + obj.K4*(y_ - obj.x_pred(8));
            obj.P4 = (1 - obj.K4)*obj.P4;
             
        end
    end
end
